\documentclass{article}
\usepackage[russian]{babel}
\usepackage{ragged2e}

\begin{document}
\begin{flushleft}

\section{}
Заметим, что число, прибавленное к $i$-ому элементу в результате запроса равно $(k * i) + x - k \cdot l$. Разделим операции $<l r k x>$ на прибавление $k$ к условному $b[i]$ и $x - k \cdot l$ к условному $c[i]$. Тогда $a[i] = b[i] * i + c[i]$.

Заведем массив $b$ и $c$. При запросе $<l r k x>$ совершим действия:
$b[l] = b[l] + k$

$b[r + 1] = b[r + 1] - k$

$c[l] = c[l] + x - k \cdot l$

$с[r + 1] = c[r + 1] - (x - k \cdot l)$

После чего посчитаем префикс-суммы массивов $b$ и $c$, они будут искомыми значениями для подсчета массива $a$. 


\section{}

\section{}

\section{}

Научимся отвечать на запрос "Пометить вершину" и "Наименьший непомеченный предок вершины". Для этого подойдет использование HLD (для каждого ДО будем хранить также самую нижнюю не помеченную вершину, чтобы в случае запроса к всему дереву отвечать за $O(1)$, это значение можно обновлять при покраске вершин за $O(\log{n})$) ($<O(n), O(\log{n})>$). Для ответа на запрос "Наименьший непомеченный общий предок" достаточно найти LCA ($<O(n), O(\log{n}>$) и найти его наименьшего непомеченного предка.

(Вместо HLD для этой задачи подходит использование DSU (но не подходит для задачи 5) при покраске вершины просто назначаем ее лидером в DSU лидера ее предка, т.о лидер вершины - ближайший не покрашенный предок)


\section{}

Решение из задачи 4 остается актуальным.

\end{flushleft}
\end{document}